# Generated by r6-generator-maven-plugin: do not edit by hand
#' This is the main entry point of the html2pdfr generated R library.
#'
#' @description
#' R wrapper for OpenHTMLtoPDF java library
#'
#' Version: 0.3.0
#'
#' Generated: 2022-06-22T23:45:53.329279
#'
#' Contact: rob.challen@bristol.ac.uk
#' @import extrafont
#' @import rJava
#' @export
JavaApi = R6::R6Class("JavaApi", public=list( 
	#### fields ----
	#' @field .log a pointer to the java logging system
	.log = NULL,
	#' @field .fromJava a set of type conversion functions from Java to R
	.fromJava = NULL,
	#' @field .toJava a set of type conversion functions from R to Java
	.toJava = NULL,
	#' @field .reg the list of references to java objects created by this API 
	.reg = list(),
	#' @field HtmlConverter the HtmlConverter class contructors and static methods
	HtmlConverter = NULL,

	#' @description
	#' change the java logging level
	#' @param logLevel A string such as "DEBUG", "INFO", "WARN"
	#' @return nothing
	changeLogLevel = function(logLevel) {
		.jcall("uk/co/terminological/rjava/LogController", returnSig = "V", method = "changeLogLevel" , logLevel)
		invisible(NULL)
	},
	
	#' @description
	#' change the java logging level using a log4j configuration file
	#' @param log4jproperties An absolute filepath to the log4j propertied file
	#' @return nothing
	reconfigureLog = function(log4jproperties) {
		.jcall("uk/co/terminological/rjava/LogController", returnSig = "V", method = "reconfigureLog" , log4jproperties)
		invisible(NULL)
	},
	
	#' @description
	#' print java system messages to the R console and flush the message cache. This is generally called automatically,
	#' @return nothing
	printMessages = function() {
		# check = FALSE here to stop exceptions being cleared from the stack.
		message(.jcall("uk/co/terminological/rjava/LogController", returnSig = "Ljava/lang/String;", method = "getSystemMessages", check=FALSE))
		invisible(NULL)
	},
	
 	#### constructor ----
 	#' @description
 	#' Create the R6 api library class. This is the entry point to all Java related classes and methods in this package.
	#' @param logLevel One of "OFF", "FATAL", "ERROR", "WARN", "INFO", "DEBUG", "TRACE", "ALL". (defaults to "WARN") 
	#' @examples
	#' \dontrun{
	#' J = html2pdfr::JavaApi$get();
	#' }
	#' @return nothing
 	initialize = function(logLevel = "WARN") {
 		if (is.null(JavaApi$singleton)) stop("Startup the java api with JavaApi$get() rather than using this constructor directly")
 	
 		message("Initialising R wrapper for OpenHTMLtoPDF java library")
 		message("Version: 0.3.0")
		message("Generated: 2022-06-22T23:45:53.329572")
 	
 	
		if (!.jniInitialized) 
			.jinit(parameters=getOption("java.parameters"),silent = TRUE, force.init = FALSE)
		
		# Java dependencies
		jars = .checkDependencies(quiet = TRUE)
		.jaddClassPath(jars)
		
		# configure logging
 		.jcall("uk/co/terminological/rjava/LogController", returnSig = "V", method = "setupRConsole")
 		.jcall("uk/co/terminological/rjava/LogController", returnSig = "V", method = "configureLog" , logLevel)
 		# TODO: this is the library build date code but it requires testing
 		buildDate = .jcall("uk/co/terminological/rjava/LogController", returnSig = "S", method = "getClassBuildTime")
		self$.log = .jcall("org/slf4j/LoggerFactory", returnSig = "Lorg/slf4j/Logger;", method = "getLogger", "html2pdfr");
		.jcall(self$.log,returnSig = "V",method = "debug", "Adding to classpath: ")
		for (jar in jars) {
		  .jcall(self$.log,returnSig = "V",method = "debug", jar)
		}
		.jcall(self$.log,returnSig = "V",method = "info","Initialised html2pdfr");
		.jcall(self$.log,returnSig = "V",method = "debug","R package version: 0.3.0");
		.jcall(self$.log,returnSig = "V",method = "debug","R package generated: 2022-06-22T23:45:53.329682");
		.jcall(self$.log,returnSig = "V",method = "debug","Java library version: com.github.terminological:html2pdfr:main-SNAPSHOT");
		.jcall(self$.log,returnSig = "V",method = "debug",paste0("Java library compiled: ",buildDate));
		.jcall(self$.log,returnSig = "V",method = "debug","Contact: rob.challen@bristol.ac.uk");
		self$printMessages()
		
		# initialise type conversion functions
		
		self$.toJava = list(
			RNumericArray=function(rObj) {
				if (is.null(rObj)) return(rJava::.jnew('uk/co/terminological/rjava/types/RNumericArray'))
				if (!is.numeric(rObj)) stop('expected a numeric')
				if (!is.array(rObj)) stop('expected an array')
				tmpVec = as.vector(as.numeric(rObj))
				tmpDim = dim(rObj)
				return(rJava::.jnew('uk/co/terminological/rjava/types/RNumericArray',rJava::.jarray(tmpVec),rJava::.jarray(tmpDim)))
			},
			RDateVector=function(rObj) {
				if (is.null(rObj)) return(rJava::.new('uk/co/terminological/rjava/types/RDateVector'))
				if (any(na.omit(rObj)<'0001-01-01')) message('dates smaller than 0001-01-01 will be converted to NA')
				tmp = as.character(rObj,format='%C%y-%m-%d')
				return(rJava::.jnew('uk/co/terminological/rjava/types/RDateVector',rJava::.jarray(tmp)))
			},
			RDate=function(rObj) {
				if (is.na(rObj)) return(rJava::.jnew('uk/co/terminological/rjava/types/RDate'))
				if (length(rObj) > 1) stop('input too long')
			   if (rObj<'0001-01-01') message('dates smaller than 0001-01-01 will be converted to NA')
				tmp = as.character(rObj,format='%C%y-%m-%d')[[1]]
				return(rJava::.jnew('uk/co/terminological/rjava/types/RDate',tmp))
			},
			RCharacterVector=function(rObj) {
				if (is.null(rObj)) return(rJava::.jnew('uk/co/terminological/rjava/types/RCharacterVector'))
				if (!is.character(rObj)) stop('expected a vector of characters')
				tmp = as.character(rObj)
				return(rJava::.jnew('uk/co/terminological/rjava/types/RCharacterVector',rJava::.jarray(tmp)))
			},
			RNumeric=function(rObj) {
				if (length(rObj) > 1) stop('input too long')
				if (!is.numeric(rObj)) stop('expected a numeric')
				tmp = as.numeric(rObj)[[1]]
				return(rJava::.jnew('uk/co/terminological/rjava/types/RNumeric',tmp))
			},
			RFactor=function(rObj) {
				if (is.na(rObj)) return(rJava::.jnew('uk/co/terminological/rjava/types/RFactor'))
				if (length(rObj) > 1) stop('input too long')
				tmp = as.integer(rObj)[[1]]
				tmpLabel = levels(rObj)[[tmp]]
				return(rJava::.jnew('uk/co/terminological/rjava/types/RFactor',tmp, tmpLabel))
			},
			RLogical=function(rObj) {
				if (is.na(rObj)) return(rJava::.jnew('uk/co/terminological/rjava/types/RLogical'))
				if (length(rObj) > 1) stop('input too long')
				if (!is.logical(rObj)) stop('expected a logical')
				tmp = as.integer(rObj)[[1]]
				return(rJava::.jnew('uk/co/terminological/rjava/types/RLogical',tmp))
			},
			RNull=function(rObj) {
				if (!is.null(rObj)) stop('input expected to be NULL')
				return(rJava::.jnew('uk/co/terminological/rjava/types/RNull'))
			},
			RLogicalVector=function(rObj) {
				if (is.null(rObj)) return(rJava::.jnew('uk/co/terminological/rjava/types/RLogicalVector'))
				if (!is.logical(rObj)) stop('expected a vector of logicals')
				tmp = as.integer(rObj)
				return(rJava::.jnew('uk/co/terminological/rjava/types/RLogicalVector',rJava::.jarray(tmp)))
			},
			RCharacter=function(rObj) {
				if (is.na(rObj)) return(rJava::.jnew('uk/co/terminological/rjava/types/RCharacter'))
				tmp = as.character(rObj)[[1]]
				return(rJava::.jnew('uk/co/terminological/rjava/types/RCharacter',tmp))
			},
			String=function(rObj) return(as.character(rObj)),
			HtmlConverter=function(rObj) return(rObj$.jobj),
			void=function(rObj) stop('no input expected'),
			double=function(rObj) {
			    if (is.na(rObj)) stop('cant use NA as input to java double')
			    if (length(rObj) > 1) stop('input too long')
			    if (!is.numeric(rObj)) stop('not an double')
			    return(as.numeric(rObj[[1]]))
			},
			RList=function(rObj) {
			   if (!is.list(rObj)) stop ('expecting a list ')
			   if (!is.null(names(rObj))) warning('not expecting list to be named')
				jout = rJava::.jnew('uk/co/terminological/rjava/types/RList')
				lapply(rObj, function(x) {
					if (is.null(x)) tmp = self$.toJava$RNull(x)
					else if (is.data.frame(x)) tmp = self$.toJava$RDataframe(x)
					else if (is.list(x) & !is.null(names(x))) tmp = self$.toJava$RNamedList(x)
					else if (is.list(x)) tmp = self$.toJava$RList(x)
					else if (is.array(x) & is.numeric(x)) tmp = self$.toJava$RNumericArray(x)
					else if (length(x) == 1 & is.character(x)) tmp = self$.toJava$RCharacter(x)
					else if (length(x) == 1 & is.integer(x)) tmp = self$.toJava$RInteger(x)
					else if (length(x) == 1 & is.factor(x)) tmp = self$.toJava$RFactor(x)
					else if (length(x) == 1 & is.logical(x)) tmp = self$.toJava$RLogical(x)
					else if (length(x) == 1 & is.numeric(x)) tmp = self$.toJava$RNumeric(x)
					else if (length(x) == 1 & inherits(x,c('Date','POSIXt'))) tmp = self$.toJava$RDate(x)
					else if (is.character(x)) tmp = self$.toJava$RCharacterVector(x)
					else if (is.integer(x)) tmp = self$.toJava$RIntegerVector(x)
					else if (is.factor(x)) tmp = self$.toJava$RFactorVector(x)
					else if (is.logical(x)) tmp = self$.toJava$RLogicalVector(x)
					else if (is.numeric(x)) tmp = self$.toJava$RNumericVector(x)
					else if (inherits(x,c('Date','POSIXt'))) tmp = self$.toJava$RDateVector(x)
					else stop ('unrecognised type: ',class(x),' with value ',x)
					rJava::.jcall(jout,returnSig='Z',method='add',rJava::.jcast(tmp, new.class='uk/co/terminological/rjava/types/RObject'))
				})
				return(jout)
			},
			RNumericVector=function(rObj) {
				if (is.null(rObj)) return(rJava::.jnew('uk/co/terminological/rjava/types/RNumericVector'))
				if (!is.numeric(rObj)) stop('expected a numeric')
				tmp = as.numeric(rObj)
				return(rJava::.jnew('uk/co/terminological/rjava/types/RNumericVector',rJava::.jarray(tmp)))
			},
			int=function(rObj) {
			    if (is.na(rObj)) stop('cant use NA as input to java int')
			    if (length(rObj) > 1) stop('input too long')
			    if (as.integer(rObj)[[1]]!=rObj[[1]]) stop('not an integer')
			    return(as.integer(rObj[[1]]))
			},
			boolean=function(rObj) {
			    if (is.na(rObj)) stop('cant use NA as input to java boolean')
			    if (length(rObj) > 1) stop('input too long')
			    if (!is.logical(rObj)) stop('not a logical')
			    return(as.logical(rObj[[1]]))
			},
			RInteger=function(rObj) {
				if (is.na(rObj)) return(rJava::.jnew('uk/co/terminological/rjava/types/RInteger'))
				if (length(rObj) > 1) stop('input too long')
				tmp = as.integer(rObj)[[1]]
				if (rObj[[1]]!=tmp) stop('cannot cast to integer: ',rObj)
				return(rJava::.jnew('uk/co/terminological/rjava/types/RInteger',tmp))
			},
			RBoundDataframe=function(rObj) {
				jout = rJava::.jnew('uk/co/terminological/rjava/types/RDataframe')
				lapply(colnames(rObj), function(x) {
					rcol = rObj[[x]]
					if(is.character(rcol)) jvec = self$.toJava$RCharacterVector(rcol)
					else if(is.integer(rcol)) jvec = self$.toJava$RIntegerVector(rcol)
					else if(is.factor(rcol)) jvec = self$.toJava$RFactorVector(rcol)
					else if(is.logical(rcol)) jvec = self$.toJava$RLogicalVector(rcol)
					else if(is.numeric(rcol)) jvec = self$.toJava$RNumericVector(rcol)
					else if(inherits(rcol,c('Date','POSIXt'))) jvec = self$.toJava$RDateVector(rcol)
					else stop('unsupported data type in column: ',x)
					rJava::.jcall(jout,returnSig='V',method='addCol',x,rJava::.jcast(jvec,new.class='uk/co/terminological/rjava/types/RVector'))
				})
				rJava::.jcall(jout,returnSig='Luk/co/terminological/rjava/types/RDataframe;',method='groupBy',rJava::.jarray(dplyr::group_vars(rObj)))
				return(jout)
			},
			RDataframe=function(rObj) {
				jout = rJava::.jnew('uk/co/terminological/rjava/types/RDataframe')
				lapply(colnames(rObj), function(x) {
					rcol = rObj[[x]]
					if(is.character(rcol)) jvec = self$.toJava$RCharacterVector(rcol)
					else if(is.integer(rcol)) jvec = self$.toJava$RIntegerVector(rcol)
					else if(is.factor(rcol)) jvec = self$.toJava$RFactorVector(rcol)
					else if(is.logical(rcol)) jvec = self$.toJava$RLogicalVector(rcol)
					else if(is.numeric(rcol)) jvec = self$.toJava$RNumericVector(rcol)
					else if(inherits(rcol,c('Date','POSIXt'))) jvec = self$.toJava$RDateVector(rcol)
					else stop('unsupported data type in column: ',x)
					rJava::.jcall(jout,returnSig='V',method='addCol',x,rJava::.jcast(jvec,new.class='uk/co/terminological/rjava/types/RVector'))
				})
				rJava::.jcall(jout,returnSig='Luk/co/terminological/rjava/types/RDataframe;',method='groupBy',rJava::.jarray(dplyr::group_vars(rObj)))
				return(jout)
			},
			RUntypedNaVector=function(rObj) {
				if (is.null(rObj)) return(rJava::.new('uk/co/terminological/rjava/types/RUntypedNaVector'))
				return(rJava::.jnew('uk/co/terminological/rjava/types/RUntypedNaVector',length(rObj)))
			},
			RUntypedNa=function(rObj) {
				return(rJava::.jnew('uk/co/terminological/rjava/types/RUntypedNa'))
			},
			RFactorVector=function(rObj) {
				if (is.null(rObj)) return(rJava::.jnew('uk/co/terminological/rjava/types/RFactorVector'))
				if (!is.factor(rObj)) stop('expected a vector of factors')
				tmp = as.integer(rObj)
				return(rJava::.jnew('uk/co/terminological/rjava/types/RFactorVector', rJava::.jarray(tmp), rJava::.jarray(levels(rObj))))
			},
			RIntegerVector=function(rObj) {
				if (is.null(rObj)) return(rJava::.jnew('uk/co/terminological/rjava/types/RIntegerVector'))
				tmp = as.integer(rObj)
				if (any(rObj!=tmp,na.rm=TRUE)) stop('cannot coerce to integer: ',rObj)
				return(rJava::.jnew('uk/co/terminological/rjava/types/RIntegerVector',rJava::.jarray(tmp)))
			},
			RNamedList=function(rObj) {
				if (!is.list(rObj) | is.null(names(rObj))) stop ('expecting a named list')
				jout = rJava::.jnew('uk/co/terminological/rjava/types/RNamedList')
				lapply(names(rObj), function(name) {
					x = rObj[[name]]
					if (is.null(x)) tmp = self$.toJava$RNull(x)
					else if (is.data.frame(x)) tmp = self$.toJava$RDataframe(x)
					else if (is.list(x) & !is.null(names(x))) tmp = self$.toJava$RNamedList(x)
					else if (is.list(x)) tmp = self$.toJava$RList(x)
					else if (is.array(x) & is.numeric(x)) tmp = self$.toJava$RNumericArray(x)
					else if (length(x) == 1 & is.character(x)) tmp = self$.toJava$RCharacter(x)
					else if (length(x) == 1 & is.integer(x)) tmp = self$.toJava$RInteger(x)
					else if (length(x) == 1 & is.factor(x)) tmp = self$.toJava$RFactor(x)
					else if (length(x) == 1 & is.logical(x)) tmp = self$.toJava$RLogical(x)
					else if (length(x) == 1 & is.numeric(x)) tmp = self$.toJava$RNumeric(x)
					else if (length(x) == 1 & inherits(x,c('Date','POSIXt'))) tmp = self$.toJava$RDate(x)
					else if (is.character(x)) tmp = self$.toJava$RCharacterVector(x)
					else if (is.integer(x)) tmp = self$.toJava$RIntegerVector(x)
					else if (is.factor(x)) tmp = self$.toJava$RFactorVector(x)
					else if (is.logical(x)) tmp = self$.toJava$RLogicalVector(x)
					else if (is.numeric(x)) tmp = self$.toJava$RNumericVector(x)
					else if (inherits(x,c('Date','POSIXt'))) tmp = self$.toJava$RDateVector(x)
					else stop ('unrecognised type: ',class(x),' with value ',x)
					rJava::.jcall(jout,returnSig='Luk/co/terminological/rjava/types/RObject;',method='put',name,rJava::.jcast(tmp, new.class='uk/co/terminological/rjava/types/RObject'))
				})
				return(jout)
			}		)
		
		self$.fromJava = list(
			RNumericArray=function(jObj) {
				tmpVec = as.numeric(rJava::.jcall(jObj,returnSig='[D',method='rPrimitive'))
				tmpDim = as.integer(rJava::.jcall(jObj,returnSig='[I',method='rDim'))
			   if (length(tmpDim)==2) return(matrix(tmpVec,tmpDim))
				return(array(tmpVec,tmpDim))
			},
			RDateVector=function(jObj) as.Date(rJava::.jcall(jObj,returnSig='[Ljava/lang/String;',method='rPrimitive'),'%Y-%m-%d'),
			RDate=function(jObj) as.Date(rJava::.jcall(jObj,returnSig='Ljava/lang/String;',method='rPrimitive'),'%Y-%m-%d'),
			RCharacterVector=function(jObj) as.character(rJava::.jcall(jObj,returnSig='[Ljava/lang/String;',method='rPrimitive')),
			RNumeric=function(jObj) as.numeric(rJava::.jcall(jObj,returnSig='D',method='rPrimitive')),
			RFactor=function(jObj) as.character(rJava::.jcall(jObj,returnSig='Ljava/lang/String;',method='rLabel')),
			RLogical=function(jObj) as.logical(rJava::.jcall(jObj,returnSig='I',method='rPrimitive')),
			RNull=function(jObj) return(NULL),
			RLogicalVector=function(jObj) as.logical(rJava::.jcall(jObj,returnSig='[I',method='rPrimitive')),
			RCharacter=function(jObj) as.character(rJava::.jcall(jObj,returnSig='Ljava/lang/String;',method='rPrimitive')),
			String=function(jObj) return(as.character(jObj)),
			HtmlConverter=function(jObj) return(jObj),
			void=function(jObj) invisible(NULL),
			double=function(jObj) return(as.numeric(jObj)),
			RList=function(jObj) {
				tmp = eval(parse(text=rJava::.jcall(jObj,'rCode', returnSig='Ljava/lang/String;')))
				return(tmp)
			},
			RNumericVector=function(jObj) as.numeric(rJava::.jcall(jObj,returnSig='[D',method='rPrimitive')),
			int=function(jObj) return(as.integer(jObj)),
			boolean=function(jObj) return(as.logical(jObj)),
			RInteger=function(jObj) as.integer(rJava::.jcall(jObj,returnSig='I',method='rPrimitive')),
			RBoundDataframe=function(jObj) {
				convDf = eval(parse(text=rJava::.jcall(jObj,'rConversion', returnSig='Ljava/lang/String;')))
				groups = rJava::.jcall(jObj,returnSig='[Ljava/lang/String;',method='getGroups')
				return(dplyr::group_by(convDf(jObj),!!!sapply(groups,as.symbol)))
			},
			RDataframe=function(jObj) {
				convDf = eval(parse(text=rJava::.jcall(jObj,'rConversion', returnSig='Ljava/lang/String;')))
				groups = rJava::.jcall(jObj,returnSig='[Ljava/lang/String;',method='getGroups')
				return(dplyr::group_by(convDf(jObj),!!!sapply(groups,as.symbol)))
			},
			RUntypedNaVector=function(jObj) rep(NA, rJava::.jcall(jObj,returnSig='I',method='size')),
			RUntypedNa=function(jObj) return(NA),
			RFactorVector=function(jObj) ordered(
				x = rJava::.jcall(jObj,returnSig='[I',method='rValues'),
				labels = rJava::.jcall(jObj,returnSig='[Ljava/lang/String;',method='rLevels')
			),
			RIntegerVector=function(jObj) as.integer(rJava::.jcall(jObj,returnSig='[I',method='rPrimitive')),
			RNamedList=function(jObj) {
				tmp = eval(parse(text=rJava::.jcall(jObj,'rCode', returnSig='Ljava/lang/String;')))
				return(tmp)
			}		)
	
		# initialise java class constructors and static method definitions
		
		self$HtmlConverter = list(
			new = function(fontfiles=extrafont::fonttable()$fontfile) {
				# constructor
				# convert parameters to java
				tmp_fontfiles = self$.toJava$RCharacterVector(fontfiles);
				# invoke constructor method
				tmp_out = .jnew("uk/co/terminological/html2pdfr/HtmlConverter" , tmp_fontfiles, check=FALSE);
				self$printMessages()
				.jcheck() 
				# convert result back to R (should be a identity conversion)
				tmp_r6 = HtmlConverter$new(
					self$.fromJava$HtmlConverter(tmp_out),
					self
				);
				return(tmp_r6)
			}
	)
	}
))

JavaApi$singleton = NULL

JavaApi$get = function(logLevel = "WARN") {
	if (is.null(JavaApi$singleton)) {
		# set to non-null so that R6 constructor will work
		JavaApi$singleton = FALSE 
		JavaApi$singleton = JavaApi$new(logLevel)
	}
	return(JavaApi$singleton)
}

JavaApi$rebuildDependencies = function( ... ) {
	# remove working directory
	unlink(.workingDir(), recursive = TRUE)
	# rebuild everything
	classpath = .checkDependencies(quiet = FALSE, ...)
	
	# find the jars that come bundled with the library:
	jars = list.files(.here("java"), pattern=".*\\.jar", full.names = TRUE)
	jars = jars[!endsWith(jars,"sources.jar") & !endsWith(jars,"javadoc.jar") & !endsWith(jars,"src.jar")]
	
	# and add any that have been resolved and downloaded by maven:
	jars = unique(c(jars,classpath))
	
	if (!all(file.exists(jars))) {
		warning("The library has been rebuilt but there is still some missing dependencies: Out of the following")
		warning(paste0(jars,collapse="\n"))
		warning("The missing dependencies are:")
		warning(paste0(jars[file.exists(jars)],collapse="\n"))
		warning("Please double check this is not an issue with your connections etc")
		warning("The output of html2pdfr::JavaApi$rebuildDependencies(debug=TRUE) may help diagnose the problem")
	}
	
	return(jars)
}


## package private utility functions for managing maven dependencies ----
# as this is generated code configuration is hard coded here
# i.e. these functions are specific for the configuration of this package.

.checkDependencies = function(...) {
	# Java dependencies
	# the main java library has been compiled but external dependencies must be resolved by maven
	# successful resolution of the classpath libraries depends on the runtime machine and requires
	# access to the internet at a minimum.
	pomLoc = .extractPom()
	classpath = .resolveDependencies(pomLoc, ...) 
	
	# find the jars that come bundled with the library:
	jars = list.files(.here("java"), pattern=".*\\.jar", full.names = TRUE)
	jars = jars[!endsWith(jars,"sources.jar") & !endsWith(jars,"javadoc.jar") & !endsWith(jars,"src.jar")]
	
	# and add any that have been resolved and downloaded by maven:
	jars = unique(c(jars,classpath))
	return(jars)
}

# package working directory
.workingDir = function() {
	tmp = path.expand(rappdirs::user_cache_dir("html2pdfr-0.3.0"))
	fs::dir_create(tmp)
	return(tmp)
}

# package installation directory
.here = function(paths) {
	path.expand(system.file(paths, package="html2pdfr"))
}

# loads a maven wrapper distribution from the internet and unzips it into the package working directory
.loadMavenWrapper = function() {
	dir = .workingDir()
	if (!file.exists(paste0(dir,"/mvnw"))) {
		destfile = paste0(dir,"/wrapper.zip")
		message("Bootstrapping maven wrapper.")
		utils::download.file(
			"https://repo1.maven.org/maven2/org/apache/maven/wrapper/maven-wrapper-distribution/3.1.1/maven-wrapper-distribution-3.1.1-bin.zip",
			destfile = destfile,
			quiet = TRUE
		)
		utils::unzip(destfile,exdir=dir)
		unlink(destfile)
		if(!file.exists(paste0(dir,"/mvnw"))) stop("downloading maven wrapper has not been successful")
	}
	if(.Platform$OS.type == "windows") {
		mvnPath = paste0(dir,"/mvnw.cmd")
	} else {
		mvnPath = paste0(dir,"/mvnw")
	}
	write(c(
		"distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.3.9/apache-maven-3.3.9-bin.zip",
		"wrapperUrl=https://repo.maven.apache.org/maven2/org/apache/maven/wrapper/maven-wrapper/3.1.1/maven-wrapper-3.1.1.jar"
	), paste0(dir,"/.mvn/wrapper/maven-wrapper.properties"))
	Sys.chmod(mvnPath)
	return(mvnPath)
}

# detect if `test` file exists and is newer that `original`
.fileNewer = function(original, test) {
	if (!file.exists(original)) stop("source file doesn't exist")
	if (!file.exists(test)) return(FALSE)
	as.POSIXct(file.info(original)$mtime) < as.POSIXct(file.info(test)$mtime)
}

# gets the pom.xml file for com.github.terminological:html2pdfr:main-SNAPSHOT from a thin jar
.extractPom = function() {
	dir = .workingDir()
	jarLoc = list.files(.here(c("inst/java","java")), pattern = "html2pdfr-main-SNAPSHOT\\.jar", full.names = TRUE)
	if (length(jarLoc)==0) stop("couldn't find jar for artifact: html2pdfr-main-SNAPSHOT")
	jarLoc = jarLoc[[1]]
	pomPath = paste0(dir,"/pom.xml")
	if (!.fileNewer(jarLoc, pomPath)) {
		utils::unzip(jarLoc, files = "META-INF/maven/com.github.terminological/html2pdfr/pom.xml", junkpaths = TRUE, exdir = dir)
		if (!file.exists(pomPath)) stop("couldn't extract META-INF/maven/com.github.terminological/html2pdfr/pom.xml from ",jarLoc)
	}
	return(pomPath)
}

# gets the pom.xml file for com.github.terminological:html2pdfr:main-SNAPSHOT which is the library version we exepct to be bundled in the 
.extractSources = function() {
	dir = .workingDir()
	jarLoc = list.files(.here(c("inst/java","java")), pattern = "html2pdfr-main-SNAPSHOT-src\\.jar", full.names = TRUE)
	if (length(jarLoc)==0) stop("couldn't find jar for artifact: html2pdfr-main-SNAPSHOT-src.jar")
	jarLoc = jarLoc[[1]]
	pomPath = paste0(dir,"/html2pdfr-main-SNAPSHOT/pom.xml")
	if (!.fileNewer(jarLoc, pomPath)) {
		utils::unzip(jarLoc, exdir = dir)
		if (!file.exists(pomPath)) stop("couldn't extract source files from ",jarLoc)
	}
	return(pomPath)
}

# executes maven assembly plugin and relocates resulting fat jar into java library directory
.compileFatJar = function(pomPath, ...) {
	fatJarFinal = fs::path(.here("java"),"html2pdfr-main-SNAPSHOT-jar-with-dependencies.jar")
	if (!.fileNewer(pomPath, fatJarFinal)) {
		message("Compiling java library and downloading dependencies, please be patient.")
		.executeMaven(
			pomPath, 
			goal = c("compile","assembly:assembly"),
			opts = c(
				"-DdescriptorId=jar-with-dependencies",
				"-Dmaven.test.skip=true"
			),
			...
		)
		message("Compilation complete")
		fatJar = fs::path_norm(fs::path(pomPath, "../target/html2pdfr-main-SNAPSHOT-jar-with-dependencies.jar"))
		fs::file_move(fatJar, fatJarFinal)
	}
	return(fatJarFinal)
}

# execute a `dependency:build-classpath` maven goal on the `pom.xml`
.resolveDependencies = function(pomPath, ...) {
	classpathLoc = paste0(.workingDir(), "/classpath.txt" )
	# If the classpath file is already there we need to check that the entries on the class path are indeed available on this machine
	# as they may have been moved or deleted
	if(file.exists(classpathLoc)) {
		classpathString = unique(readLines(classpathLoc,warn = FALSE))
		if (!all(file.exists(classpathString))) {
			# we need to rebuild the classpath file as some dependencies are not available
			unlink(classpathLoc)
		}
	} 
	if(!.fileNewer(pomPath,classpathLoc)) {
		message("Calculating classpath and updating dependencies, please be patient.")
		.executeMaven(
			pomPath, 
			goal = "dependency:build-classpath",		
			opts = c(
				paste0("-Dmdep.outputFile=classpath.txt"),
				paste0("-DincludeScope=runtime")
			),
			...
		)
		message("Dependencies updated")
	}
	
	if(.Platform$OS.type == "windows") {
	  classpathString = unique(scan(classpathLoc, what = "character", sep=";", quiet=TRUE))
	} else {
	  classpathString = unique(scan(classpathLoc, what = "character", sep=":", quiet=TRUE))
	}
	
	if (!all(file.exists(classpathString))) 
		stop("For some inexplicable reason, Maven cannot determine the classpaths of the dependencies of this library on this machine. You can try html2pdfr::JavaApi$rebuildDependencies()")
	return(classpathString)
}

# executes a maven goal plus or minus info or debugging
.executeMaven = function(pomPath, goal, opts = c(), quiet=TRUE, debug=FALSE, ...) {
	mvnPath = .loadMavenWrapper()
	args = c(goal, opts) #, paste0("-f '",pomPath,"'"))
	if (quiet) args = c(args, "-q")
	if (debug) args = c(args, "-X")
	java_home = rJava::.jcall( 'java/lang/System', 'S', 'getProperty', 'java.home' )
	Sys.setenv(JAVA_HOME=java_home)
	# required due to an issue in Mvnw.cmd on windows.
	wd = getwd()
	setwd(.workingDir())
	system2(mvnPath, args)
	setwd(wd)
}

